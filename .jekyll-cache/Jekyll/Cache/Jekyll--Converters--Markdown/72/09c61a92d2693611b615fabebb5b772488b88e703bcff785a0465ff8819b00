I"<h3 id="os의-구조">OS의 구조</h3>

<ul>
  <li>User Interfaces
    <ul>
      <li>GUI, batch, command line</li>
    </ul>
  </li>
  <li>System Calls</li>
  <li>Kernal
    <ul>
      <li>program execution, I/O operations, file systems, communication, resource allocation, accounting, error detections, protection and secuirty</li>
    </ul>
  </li>
</ul>

<h3 id="computer-hardware">Computer Hardware</h3>

<ul>
  <li>System Bus</li>
  <li>CPU</li>
  <li>Disk Controller</li>
  <li>USB Controller</li>
  <li>Graphics Adapter</li>
  <li>Memory</li>
</ul>

<h5 id="system-bus">System Bus</h5>

<ul>
  <li>각 요소들 연결</li>
  <li>종류
    <ul>
      <li>Data Bus - 데이터 전송</li>
      <li>Command/Address Bus - 명령어(Read, Write)와 주소 전달</li>
    </ul>
  </li>
  <li>요소
    <ul>
      <li>Bus Arbiter(관리자) - 충돌 방지</li>
      <li>Bus Master - bus transaction을 요청하는 부류
        <ul>
          <li>CPU, DMA controller(다이렉트 메모리 엑세스)</li>
        </ul>
      </li>
      <li>Bus Slave - bus master로부터 요청을 받는 부류
        <ul>
          <li>상황에 따라 모든 요소 포함</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h5 id="io-operations">I/O Operations</h5>

<ul>
  <li>I/O 컨트롤러가 CPU 요청에 따라 각각의 I/O operation 실행</li>
  <li>I/O 컨트롤러 레지스터
    <ul>
      <li>데이터 레지스터</li>
      <li>컨트롤 레지스터 - 대기열</li>
    </ul>
  </li>
  <li>
    <p>작동 방식</p>

    <ol>
      <li><strong>Read</strong> status register of the I/O controller - 가용 상태인지 확인</li>
      <li><strong>Write</strong> data to I/O Controller</li>
    </ol>

    <ul>
      <li>사용 불가능한 경우 지속적으로 Read</li>
    </ul>
  </li>
  <li>Polling &amp; Interrput-driven
    <ul>
      <li>I/O status를 어떻게 확인할 것인지</li>
      <li>Polling - CPU가 I/O status를 지속적으로 확인</li>
      <li>Interrupt-Driven - I/O 컨트롤러가 작업 가능을 CPU에 얄려줌</li>
    </ul>
  </li>
  <li>Memory-mapped &amp; Port-mapped
    <ul>
      <li>I/O 레지스터 접근을 어떻게 할 것인지</li>
      <li>Memory-mapped - 메모리에 I/O 주소를 사용</li>
      <li>Port-mapped - 별개의 포트로 I/O 주소 사용</li>
    </ul>
  </li>
</ul>

<h5 id="interrupts-mechanism">Interrupts Mechanism</h5>

<p><em><strong>CPU 외부에서</strong> CPU에게 이벤트 발생을 알려 CPU의 흐름을 방해</em></p>

<ul>
  <li>ISR(Interrupt Service Routine) - 인터럽트가 오면 어떻게 대응할 것인지 미리 정의되어 있는 함수, 인터럽트 벡터에 존재</li>
  <li>Trap, Exception - Software-Generated Interrupt, CPU 내부에서 발생시키는 인터럽트</li>
  <li>OS is <strong>Interrupt-Driven</strong></li>
</ul>

<h5 id="interrupt-handling">Interrupt Handling</h5>

<ol>
  <li>작업 중인 명령까지 수행하고 작업(레지스터값, PC값 등)을 저장</li>
  <li>인터럽트 벡터와 IRQ를 통해 ISR의 주소를 알아냄</li>
  <li>ISR 실행</li>
  <li>작업을 불러와서 재개</li>
</ol>

<h2 id="os-design-and-implementaion">OS Design and Implementaion</h2>

<h5 id="os-design">OS Design</h5>

<p><em>Not Solvable, 정답은 없음</em></p>

<ol>
  <li>목표, 세부사항 설정</li>
  <li>하드웨어와 시스템 선택</li>
</ol>

<ul>
  <li>Policy(무엇을 해야 하는 가), Mechanism(어떻게 할 것인가)을 구분
    <ul>
      <li>프로젝트를 유연하게 만들어줌</li>
    </ul>
  </li>
</ul>

<h5 id="os-implementation">OS Implementation</h5>

<ul>
  <li>주로 C, C++, 몇몇 부분은 기계어, 어셈블리어, 스크립트, 파이썬 등등
    <ul>
      <li>여러가지 언어의 혼합</li>
    </ul>
  </li>
  <li>High-Level은 여러 하드웨어에 포트 쉬움, 빠르고 간결한 코드, 디버깅 쉬움
    <ul>
      <li>BUT, 느림</li>
    </ul>
  </li>
  <li>핵심적인 기능 이외에는 알고리즘의 속도가 더 중요해서 High-Level 주로 사용</li>
</ul>

<h3 id="os-structure">OS Structure</h3>

<ul>
  <li>Decomposition(모듈화)</li>
  <li>Abstraction(추상화)</li>
</ul>

<h5 id="simple-structure-ms-dos">Simple-Structure (MS-DOS)</h5>

<ul>
  <li>비모듈화</li>
  <li>프로그램 -&gt; 커널 -&gt; 완료해야 다시 프로그램으로 돌아감</li>
  <li>Single Program</li>
</ul>

<h5 id="more-complex-initial-unix">More Complex (Initial UNIX)</h5>

<ul>
  <li>시스템 프로그램과 커널로 모듈화</li>
</ul>

<h5 id="layered-approach">Layered Approach</h5>

<ul>
  <li>몇 개의 레이어로 모듈화</li>
  <li>각 레이어는 바로 밑 레이어로 소통 가능</li>
</ul>

<h5 id="micro-kernal">Micro Kernal</h5>

<ul>
  <li>커널의 경량화, 필수적인 부분만 남기고 나머지는 user-level program으로</li>
  <li>message passing으로 유저 모듈간 통신
    <ul>
      <li>메모리 복사 발생 == 오버헤드 발생</li>
    </ul>
  </li>
  <li>커널 업데이트가 굉장히 쉬움 - 커널이 작아서</li>
  <li>새로운 아키텍쳐에 적용하기가 쉬움 - 커널이 작아서</li>
  <li>안정성 - 커널에서 작동하는 코드가 줄어듦</li>
  <li>보안성</li>
</ul>

<p>#####</p>
:ET