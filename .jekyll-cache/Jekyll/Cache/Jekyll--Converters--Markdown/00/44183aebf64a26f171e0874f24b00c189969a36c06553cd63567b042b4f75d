I"<h3 id="알고리즘과-문제-분석-이유">알고리즘과 문제 분석 이유</h3>

<ul>
  <li>기존 알고리즘들이 이미 분석되어 있다면 문제 해결에 있어 알고리즘 선택 가능</li>
  <li>기존 알고리즘을 개선하기 위해 새로운 알고리즘을 개발한 경우 성능 비교를 위해</li>
</ul>

<h3 id="correctness">Correctness</h3>

<p><em>input들을 항상 output으로 정확하게 바꿀 수 있는 지 증명</em></p>

<ul>
  <li>주어진 input을 만족하고</li>
  <li>알고리즘이 종료되었을 때</li>
  <li>올바른 output인 경우</li>
</ul>

<h3 id="performance">Performance</h3>

<p><em>컴퓨터의 성능, 프로그래밍 언어, 프로그래머 등의 조건과 관계없는 상황에서 알고리즘이 수행하는 연산의 양 (input 크기 n에 대해서)</em></p>

<ul>
  <li>문제 해결에 있어 핵심적인 basic operation 찾기</li>
  <li>대략적인 basic operation의 수를 측정</li>
  <li>input에 조건이 있는 경우 알고리즘의 성능에 영향을 끼칠 수 있음</li>
</ul>

<h3 id="worst-case-complexity">Worst-Case Complexity</h3>

<ul>
  <li>크기가 n인 input들의 집합 $D_n$</li>
  <li>$D_n$ 중 하나인 I에 대해서 알고리즘의 일의 양 $t(I)$</li>
  <li>$W(n) = max(t(i)\,for\,i\,in\,D(n))$
    <ul>
      <li>Input에 따라 가장 많은 일을 하는 경우</li>
    </ul>
  </li>
</ul>

<h3 id="average-complexity">Average Complexity</h3>

<ul>
  <li>인풋 $I$가 나올 확률 $Pr(I)$</li>
  <li>$A(n) = sum(Pr(I)*t(i)\,for\,i\,in\,D(n))$</li>
  <li>$t(I)$는 알고리즘 분석으로 측정할 수 있지만</li>
  <li>$Pr(I)$는 계산으로 알아내기 <strong>어렵다</strong></li>
  <li>일반적으로 $Pr(I)$는 통계적으로 측정 or 모든 발생확률이 동일하다고 가정</li>
</ul>

<h5 id="ex-search-in-unordered-array">ex. Search In Unordered Array</h5>

<blockquote>
  <p>N개의 요소를 가지고 정렬되지 않은 배열 E
특정한 값 K를 가진 인덱스를 찾고 있으면 인덱스 반환
없으면 -1 반환</p>
</blockquote>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">seqSearch</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">E</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">ans</span><span class="p">,</span> <span class="n">idx</span><span class="p">;</span>
  <span class="n">ans</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// 실패 가정</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">){</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">K</span><span class="p">){</span>
      <span class="n">ans</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span> <span class="c1">// 성공</span>
      <span class="k">break</span><span class="p">;</span> <span class="c1">// 종료</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">ans</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>$A(n) = Pr(succ)A_{succ}(n) + Pr(fail)A_{fail}(n)$
$A_{succ}(n) = \displaystyle\sum_{i=0}^{n - 1}{Pr(I_i|succ)*t(I_i)} = \frac{1}{n} \sum_{i=0}^{n-1}(i + 1)$
$= \displaystyle \frac{1}{n}\sum_{i=1}^{n}(i) = \frac{n + 1}{2}$</p>

<table>
  <tbody>
    <tr>
      <td>$A_{fail}(n) = Pr(I</td>
      <td>fail)<em>t(I_i) = 1</em>n = n$</td>
    </tr>
    <tr>
      <td>_탐색 실패는 1가지 경우 밖에 없음, $Pr(I</td>
      <td>fail) = 1$_</td>
    </tr>
  </tbody>
</table>

<p>$\displaystyle A(n) = q\frac{n+1}{2} + (1-q)n$</p>
:ET