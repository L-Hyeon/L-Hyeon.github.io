---
layout: post
title: 13335. 트럭
categories: PS
tags: [PS, BOJ, 구현]
math: true
---

<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/images/boj-og.png" />

# 트럭

### 문제

강을 가로지르는 하나의 차선으로 된 다리가 하나 있다. 이 다리를 n 개의 트럭이 건너가려고 한다. 트럭의 순서는 바꿀 수 없으며, 트럭의 무게는 서로 같지 않을 수 있다. 다리 위에는 단지 w 대의 트럭만 동시에 올라갈 수 있다. 다리의 길이는 w 단위길이(unit distance)이며, 각 트럭들은 하나의 단위시간(unit time)에 하나의 단위길이만큼만 이동할 수 있다고 가정한다. 동시에 다리 위에 올라가 있는 트럭들의 무게의 합은 다리의 최대하중인 L보다 작거나 같아야 한다. 참고로, 다리 위에 완전히 올라가지 못한 트럭의 무게는 다리 위의 트럭들의 무게의 합을 계산할 때 포함하지 않는다고 가정한다.

예를 들어, 다리의 길이 w는 2, 다리의 최대하중 L은 10, 다리를 건너려는 트럭이 트럭의 무게가 [7, 4, 5, 6]인 순서대로 다리를 오른쪽에서 왼쪽으로 건넌다고 하자. 이 경우 모든 트럭이 다리를 건너는 최단시간은 아래의 그림에서 보는 것과 같이 8 이다.

<img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/13335/1.png" />

다리의 길이와 다리의 최대하중, 그리고 다리를 건너려는 트럭들의 무게가 순서대로 주어졌을 때, 모든 트럭이 다리를 건너는 최단시간을 구하는 프로그램을 작성하라.

### 입력

입력 데이터는 표준입력을 사용한다. 입력은 두 줄로 이루어진다. 입력의 첫 번째 줄에는 세 개의 정수 n (1 ≤ n ≤ 1,000) , w (1 ≤ w ≤ 100) and L (10 ≤ L ≤ 1,000)이 주어지는데, n은 다리를 건너는 트럭의 수, w는 다리의 길이, 그리고 L은 다리의 최대하중을 나타낸다. 입력의 두 번째 줄에는 n개의 정수 a1, a2, ⋯ , an (1 ≤ ai ≤ 10)가 주어지는데, ai는 i번째 트럭의 무게를 나타낸다.

### 출력

출력은 표준출력을 사용한다. 모든 트럭들이 다리를 건너는 최단시간을 출력하라.

### 예제

##### 예제 입력 1

```
4 2 10
7 4 5 6
```

##### 예제 출력 1

```
8
```

##### 예제 입력 2

```
1 100 100
10
```

##### 예제 출력 2

```
101
```

##### 예제 입력 3

```
10 100 100
10 10 10 10 10 10 10 10 10 10
```

##### 예제 출력 3

```
110
```

### 풀이

모든 트럭이 지나갈 수 있도록 다리를 건너는 트럭을 배분하는 문제이다.
While을 통해 시간이 지나는 것을 반복으로 구현하는 것으로 시작한다.

1. 다음 트럭이 다리에 진입할 수 있는지 판별하여 다리에 진입
2. 다리 위에 있는 트럭들의 위치를 한 칸씩 이동
3. 다리를 다 건넌 트럭들은 다리에서 제거

다리를 Queue로 생성하여 FIFO로 트럭이 다리를 건너는 것을 구현한다.

```python
import sys
from collections import deque
input = sys.stdin.readline

def answer():
    N, W, L = map(int, input().split())
    trucks = list(map(int, input().split()))
    cur_weight, cur_idx = 0, 0
    bridge = deque()
    pos = list(0 for i in range(1, N + 1))

    # 시간 넘기면서 갈 수 있는 지 확인
    t = 1
    while (True):
        # 모든 트럭이 다리를 건넘
        if (cur_idx == N and len(bridge) == 0):
            break

        # 다리 진입
        if (cur_idx < N and cur_weight + trucks[cur_idx] <= L):
            bridge.append(cur_idx)
            cur_weight += trucks[cur_idx]
            cur_idx += 1
        
        # 한 칸씩 이동
        pop_flag = False
        for e in bridge:
            pos[e] += 1
            if (pos[e] == W):
                cur_weight -= trucks[e]
                pop_flag = True
        
        # 다리 탈출
        if (pop_flag):
            bridge.popleft()
            
        t += 1

    print(t)

answer()

```
