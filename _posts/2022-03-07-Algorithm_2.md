---
layout: post
title: 알고리즘 - 2
categories: Algorithm
tags: [CS, Algorithmm, 알고리즘]
---

### 알고리즘과 문제 분석 이유

- 기존 알고리즘들이 이미 분석되어 있다면 문제 해결에 있어 알고리즘 선택 가능
- 기존 알고리즘을 개선하기 위해 새로운 알고리즘을 개발한 경우 성능 비교를 위해

### Correctness

_input들을 항상 output으로 정확하게 바꿀 수 있는 지 증명_

- 주어진 input을 만족하고
- 알고리즘이 종료되었을 때
- 올바른 output인 경우

### Performance

_컴퓨터의 성능, 프로그래밍 언어, 프로그래머 등의 조건과 관계없는 상황에서 알고리즘이 수행하는 연산의 양 (input 크기 n에 대해서)_

- 문제 해결에 있어 핵심적인 basic operation 찾기
- 대략적인 basic operation의 수를 측정
- input에 조건이 있는 경우 알고리즘의 성능에 영향을 끼칠 수 있음

### Worst-Case Complexity

- 크기가 n인 input들의 집합 $D_n$
- $D_n$ 중 하나인 I에 대해서 알고리즘의 일의 양 $t(I)$
- $W(n) = max(t(i)\,for\,i\,in\,D(n))$
  - Input에 따라 가장 많은 일을 하는 경우

### Average Complexity

- 인풋 $I$가 나올 확률 $Pr(I)$
- $A(n) = sum(Pr(I)*t(i)\,for\,i\,in\,D(n))$
- $t(I)$는 알고리즘 분석으로 측정할 수 있지만
- $Pr(I)$는 계산으로 알아내기 **어렵다**
- 일반적으로 $Pr(I)$는 통계적으로 측정 or 모든 발생확률이 동일하다고 가정

##### ex. Search In Unordered Array

> N개의 요소를 가지고 정렬되지 않은 배열 E
> 특정한 값 K를 가진 인덱스를 찾고 있으면 인덱스 반환
> 없으면 -1 반환

```c
int seqSearch(int[] E, int n, int K){
  int ans, idx;
  ans = -1; // 실패 가정
  for (idx = 0; idx < n; idx++){
    if (E[idx] == K){
      ans = idx; // 성공
      break; // 종료
    }
  }
  return ans;
}
```

$A(n) = Pr(succ)A_{succ}(n) + Pr(fail)A_{fail}(n)$
$A_{succ}(n) = \displaystyle\sum_{i=0}^{n - 1}{Pr(I_i|succ)*t(I_i)} = \frac{1}{n} \sum_{i=0}^{n-1}(i + 1)$
$= \displaystyle \frac{1}{n}\sum_{i=1}^{n}(i) = \frac{n + 1}{2}$

$A_{fail}(n) = Pr(I|fail)*t(I_i) = 1*n = n$
_탐색 실패는 1가지 경우 밖에 없음, $Pr(I|fail) = 1$_

$\displaystyle A(n) = q\frac{n+1}{2} + (1-q)n$
