---
layout: post
title: 인터뷰 준비 - FE
categories: Interview
tags: [CS, Interview]
---

## Web

### 🤔쿠키, 세션, 토큰

- 쿠키
  - 서버나 사용자 정보를 클라이언트에 저장
  - Key, Value 구조
  - 사용자가 임의로 수정 가능 => 보안 취약
  - 헤더에 포함해 전달 => 트래픽 증가
- 세션
  - 서버 쪽에 사용자 정보 저장
  - 쿠키에 세션ID를 포함해 클라이언트로 전달
  - 별도 DB 필요, 서버 부하 심해짐
- 토큰
  - 인코딩된 문자열로 사용자 인증
  - 서버에 별도 DB 없어도 됨
  - 토큰 탈취 시 대처 어려움
  - 서버가 말

| 구분 | 저장 위치  | 장점                             | 단점                                                  |
| ---- | ---------- | -------------------------------- | ----------------------------------------------------- |
| 쿠키 | 클라이언트 | 빠름                             | 유저가 임의 수정 가능해 다른 사람인척 가능, 보안 취약 |
| 세션 | 서버       | 쿠키보다 안전                    | 추가 DB 필요, 서버에 부하, 느림                       |
| 토큰 | 클라이언트 | 빠름, 서버 무상태성, 무결성 유지 | 탈취 시 대처 불가능                                   |

- 세션 사용 시 쿠키에 세션 ID를 전달

| 쿠키                   | 토큰               |
| ---------------------- | ------------------ |
| 임의 수정 가능         | 무결성 보장        |
| 클라이언트가 만료 관리 | 서버에서 만료 관리 |

### 🤔JWT

- 헤더, 페이로드, 서명이 온점으로 구분된 문자열
- 헤더
  - 서명에 사용된 알고리즘 종류
  - 토큰 타입
- 페이로드
  - Key, Value 구조로 여러 정보를 포함
- 서명
  - 토큰이 변조되었는지 확인

### 🤔Web Server vs WAS

| Web 서버  | WAS                       |
| --------- | ------------------------- |
| 정적 파일 | 동적으로 요구에 맞춰 전달 |

- Web 서버와 WAS를 같이 사용
  - 웹서버가 정적에 대해서 빠르게 처리
  - 동적 요청의 경우 웹서버가 받아 WAS로 전달
  - WAS가 처리한 후 다시 웹서버로 전달
  - 클라이언트로 반환

### 🤔OAuth

- 다른 웹사이트의 계정에 대한 정보로 접근 권한 부여

1. 로그인 요청
2. Redirect로 네이버로 넘김
3. 네이버가 로그인 환경 제공
4. 네이버에 로그인
5. 네이버가 유저에게 authCode 제공
6. 유저는 네이버에게 받은 authCode로 서비스 요청
7. 서비스에서 받은 authCode를 가지고 네이버에 검증 요청
8. 검증 성공 시 Acess 허용

### 🤔MPA vs SPA

| MPA                         | SPA                                     |
| --------------------------- | --------------------------------------- |
| 각 페이지별로 자원 다운로드 | 모든 자원을 한 번에 다운받고 DOM만 수정 |
| FOUC 발생                   | 초기 로딩 오래 걸림                     |

- FOUC?
  - 처음에 스타일 적용되지 않은 채로 정보가 나오는 것

### 🤔CSR, SSR

| CSR                   | SSR         |
| --------------------- | ----------- |
| 클라이언트 렌더링     | 서버 렌더링 |
| 화면 전환 딜레이 없음 | SEO에 유리  |

- 렌더링?
  - DOM을 그리는 것

## Browser

### 🤔브라우저 구조

- UI
- 브라우저 엔진
  - 전반적인 컨트롤
- 렌더링 엔진
- 네트워킹
- UI 백엔드
  - OS의 UI API 사용
- JS 인터프리터
- 데이터 퍼시스턴스

### 🤔브라우저 동작 방법

1. HTML 파싱
   - DOM 트리 생성
2. CSS 파싱
   - CSSOM 트리 생성
3. DOM, CSSOM을 결합해 렌더 트리 생성
4. 렌더 트리 배치
   - 각 노드의 픽셀 크기 계산
5. 렌더 트리 그리기
   - UI 백엔드가 렌더 트리의 노드를 실제로 표시

- DOM?
  - HTML 태그들을 JS가 인식할 수 있는 트리 객체로 변환한 것

### 🤔주소창에 google.com을 치면 일어나는 일

1. 브라우저에 캐싱된 DNS 기록을 체크
   - 있으면 3번으로 이동
2. HTTP로 DNS 서버에 입력된 주소의 IP를 요청
   - DNS 쿼리
   - com부터 하나씩 앞으로 찾아나감
3. 찾은 IP주소에 HTML을 요청
4. 웹 서버가 응답
   - 동적 요청이 포함된 경우 WAS에게 전달
   - WAS가 동적 데이터를 가공해서 다시 웹서버로 전달
5. 응답 받은 HTML, CSS, JS 등을 브라우저가 렌더링
   - 위 브라우저 동작 방법 참조

### 🤔LocalStorage, SessionStorage

- 브라우저에 데이터를 저장하는 JS 객체
- 동일한 도메인에서만 접근 가능

| LocalStorage    | SessionStorage     |
| --------------- | ------------------ |
| 영구적          | 임시               |
| 탭 간 공유 가능 | 탭이 닫히면 없어짐 |

### 🤔IndexedDB

- 브라우저에 데이터를 저장하는 데 사용되는 API
- 비동기
- 객체 형태로 데이터 저장
- Index 이용
- 영구적, 브라우저 외부에 저장, 대용량 가능

### 🤔CORS

- XSS를 통해서 악의적인 공격을 방지하기 위해 적용하는 정책
- 같은 프로토콜, 호스트, 포트

## React

### 🤔React 작동 원리

- 가상 DOM을 이용
  - 작업을 묶어서 반영하여 재렌더링 횟수를 줄이기
- Diffing 알고리즘을 통해 변경된 부분만 실제 DOM에 반영
  - key를 통해서 고유한 노드로 구분

### 🤔생명주기

- Mounting
- Updating
- Unmounting
- 함수형 컴포넌트에서는 useEffect로 관리

### 🤔함수형 컴포넌트

- 직관적
- 불변성
  - js의 this를 사용하지 않음

### 🤔제어 컴포넌트

- 자신의 state를 가지고 변화시 재렌더링 됨
- 비제어 컴포넌트
  - state 대신 ref를 통해서 관리
  - 트리거를 통해서 재렌더링

### 🤔useMemo, useCallback

- 둘 다 최적화를 위해서 사용
- 리스트에서 값이 변화하면 새롭게 상태, 함수 생성

### 🤔FLUX 구조

- MVC 구조가 여러개로 존재하면 Model의 유지보수가 힘들어진다는 단점
- 단방향 데이터 흐름
- Action
  - 스토어에 변화를 일으키는 행동
- Dispatcher
  - 액션을 스토어로 전달
  - 데이터 흐름을 관리하는 허브
- Store
  - 상태를 저장
- View
  - 사용자와의 상호작용

액션 -> 디스패쳐 -> 스토어 -> 뷰 -> 디스패쳐

### 🤔Props Drilling

- props를 이용해 데이터를 전달할 때, 여러 단계에 거쳐 전달되어 재렌더링이 매우 많이 일어남

### 🤔상태 관리 도구

- props를 이용해서 상태를 전달하면 전달 과정에서 매우 많은 재렌더링이 발생하고, 드릴링 문제가 심해진다
- global state를 통해 필요한 부분에만 상태를 전달

### 🤔Redux

- FLUX 구조
- 리듀서가 디스패치에서 전달된 액션을 보고 스토어에 반영할 지 결정
  액션 -> 디스패치 -> 리듀서 -> 스토어

### 🤔Zustand

- React Query의 급부상으로 Redux Toolkit의 입지가 줄어들고 있다
  - Redux Toolkit은 전역 상태와 서버 상태 둘 다 관리
- 매우 작은 번들 사이즈
- 간단한 이용

### 🤔React Query

- 데이터 Fetching 라이브러리
- 데이터를 캐싱하여 새로운 요청을 보낼 지 결정
  - 트래픽 감소, 속도 증가
- 로딩, 오류 관리, 프리페칭 관리
- 가비지 컬렉션 제공

### 🤔ESLint

- JS 정적 코드 분석 도구
- 프로젝트에서 코드 스타일 유지
