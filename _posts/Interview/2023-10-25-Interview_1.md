---
layout: post
title: 인터뷰 준비 - 언어
categories: Interview
tags: [CS, Interview]
---

## C, C++

##### 1. C와 C++의 차이

| 특징        | C                       | C++                  |
| ----------- | ----------------------- | -------------------- |
| 패러다임    | 절차 지향               | 객체 지향, 절차 지향 |
| 접근법      | Top-Down                | Bottom-Up            |
| 객체        | struct                  | class                |
| 메모리 할당 | malloc, calloc, realloc | new                  |
| 메모리 해제 | free                    | delete               |

##### C의 컴파일 과정

1. 전처리기
2. 컴파일러

- Lexer(Token으로 변환)
- Parser(Parse Tree 생성)

3. 어셈블러
4. 링커

##### 포인터

- C Family의 가장 큰 특징
- 메모리를 할당 받고 해당 메모리 주소를 변수에 저장

##### C++ sort()

- 기본적으로는 Quick Sort 사용
- stable_sort는 Merge Sort 사용

##### 가상 함수

- 자식 클래스에서 반드시 오버라이딩 될 함수
- 실행 시간에 함수의 다형성 구현
- 구현부가 없으면 순수 가상 함수
  - virtual void func() = 0;
  - 순수 가상 함수가 있으면 추상 클래스

##### 정적, 동적 바인딩

- 정적 바인딩
  - 함수를 호출하는 코드를 컴파일 타임에 고정된 메모리 주소로 변환
- 동적 바인딩
  - 런타임에 함수 호출을 메모리로 변환

##### 추상 클래스

- 순수 가상 함수가 하나 이상 있는 클래스
  - 또는 class c abstract {}처럼 abstract 키워드가 붙는 클래스
- 객체 생성 불가능
- 포인터는 가능

##### friend 클래스

- friend class [클래스명]
- 친구로 등록한 클래스의 private까지 모든 멤버 사용 가능

##### 인터페이스

- 구현 객체가 같은 동작을 한다는 것을 보장
- 추상 클래스는 서로 관련이 있는 것들 사이에 중복을 제거
- 인터페이스는 관련이 없는 것 사이에 연관성 부여

## Java

##### 참조형 타입

- 정수, 실수, 논리를 제외한 모든 타입
- 직접 데이터를 저장하는 것이 아니라 주소를 저장
- 직접 주소를 핸들링 할 수는 없기에 포인터와 다름

##### 컴파일 과정

1. .java
2. 자바 컴파일러 => .class(바이트 코드)
3. JVM 클래스로더
4. 인터프리터나 JIT 컴파일러를 통해서 실행

##### 직렬화

- 객체를 외부 Java 시스템에서도 사용할 수 있도록 Byte로 변환

##### String

| String Buffer    | String Builder   |
| ---------------- | ---------------- |
| 멀티 쓰레드 환경 | 싱글 쓰레드 환경 |

##### sort()

1. byte, char, short 타입인 경우 Count Sort
2. 이외는 Quick Sort 실행
3. 최근에는 Tim Sort로 변경

##### JVM 변수 할당

- Stack
  - 지역변수, 매개변수
- Heap
  - 동적으로 할당된 데이터

##### Garvage Collection

1. Marking되지 않는 부분 탐색
2. 제거
3. 남은 메모리 묶음(한 곳으로 가져다 놈)

- Heap 영역 대상
- Young과 Old로 영역 구분
- 일단 Young 공간에 계속 놓음
- 꽉차면 GC 실행
- 마킹된 애들은 Old로 이동

##### HashMap

- HashCode()
  - 객체의 해쉬값 반환
  - 클래스의 경우 별도로 메소드를 오버라이딩 해야 내용물이 같을 떄 같은 걸로 취급 가능
- equals()
  - 두 객체의 == 결과 반환

## Python

##### Java vs Python

|        | Java                                       | Python               |
| ------ | ------------------------------------------ | -------------------- |
| 메모리 | GC                                         | GC                   |
| 실행   | 컴파일러 ->IL ->실행(인터프리터, 컴파일러) | 인터프리터           |
| 자료형 | 정적                                       | 동적(타입 선언 X)    |
| 스레딩 | 멀티 쓰레드 가능                           | 별도 라이브러리 필요 |

##### sort()

- Tim sort 알고리즘 사용
- Insertion + Merge

##### Garvage Collection

1. 참조되는 횟수 체크
2. 참조하고 있는 다른 컨테이너의 횟수 -= 1
3. 0이 되면 해당 객체는 unreachable, 메모리 회수

## JavaScript

##### sort()

- Tim sort

##### 호이스팅

- 번수는 선언, 초기화, 할당으로 이뤄짐
- 선언 과정을 최상단으로 이동시켜 코드 상 선언 이전에도 변수나 함수를 사용 가능

##### 동기, 비동기

- 동기
  - 코드의 순서대로 처리
  - 오래 걸리더라도 기다림
- 비동기
  - 오래 걸리는 작업을 처리하면서 다른 거도 같이 실행
  - Promise 리턴
  - 기존에는 콜백으로 구현 => 콜백 지옥
  - Promise 도입 이후 콜백 지옥 => Promise 지옥
  - async와 await 키워드를 통해 구현(Promise 지옥 해결법)

##### Promise

- 비동기 작업의 완료, 실패를 나타내는 JS 객체
- .then(), .catch()를 통해 성공 시 작업, 실패 시 작업을 처리

```javascript
function myPromise() {
  return new Promise((resolve, reject) => {
    if (/* 성공 조건 */) {
      resolve(/* 결과 값 */);
    } else {
      reject(/* 에러 값 */);
    }
  });
}
```

- pending, fullfilled(성공), rejected(실패) 3가지 상태를 가짐

##### Call Stack

- 하나의 호출 Stack만 사용
- 함수 하나가 끝날 때까지 다른 Task 수행 불가능

##### Event Queue

- 처리 해야하는 이벤트의 큐
- Call Stack이 비어있을 때 차례대로 진행
- 비동기 실행들은 Stack에 들어가지 않고 Queue에 들어감

참조: http://asfirstalways.tistory.com/362

## Common

##### 깊은 복사, 얕은 복사

| 얕은 복사              | 깊은 복사          |
| ---------------------- | ------------------ |
| 컨테이너의 주소를 복사 | 데이터 자체를 복사 |
| 같은 데이터를 가리킴   | 다른 데이터        |

##### OOP

- 추상화
  - 객체의 공통된 부분만을 추려 추출
- 캡슐화
  - 데이터 보호, 은닉
- 상속
  - 상위 클래스로부터 확장, 코드 반복 최소화
- 다형성
  - 객체의 속성이 상황에 따라 다른 것을 가질 수 있음
  - 오버로딩(이름만 같고 파라미터 다름)
  - 오버라이딩(완전히 다시 함수 정의)

##### P/NP

- P
  - 다항 시간 내에 해결 가능
- NP
  - 지수에 n이 포함됨
