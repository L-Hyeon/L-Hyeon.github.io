---
layout: post
title: 알고리즘 - 1
categories: Algorithm
tags: [CS, Algorithmm, 알고리즘]
---

### 컴퓨터 알고리즘이란?

- 유한시간 내에 문제를 해결할 수 있는 단계별 절차

### 문제해결 기법

1. 문제 정의
   - 인풋, 아웃풋으로 구분
1. 해결 전략 세우기
1. 알고리즘 구성
   - 인풋: 파라미터
   - 아웃풋: 리턴값
   - Step: 인풋을 아웃풋으로 변환하는 과정
1. 알고리즘 분석
   - 정확성
   - 시간, 공간 복잡도
   - 최적성: 문제 해결에 가장 적합한지 판단
1. 구현
1. 검증

#### 예제) 정렬되지 않은 배열에서의 검색

##### 문제

> N개의 요소를 가지고 정렬되지 않은 배열 E
> 특정한 값 K를 가진 인덱스를 찾고 있으면 인덱스 반환
> 없으면 -1 반환

##### 전략

- 배열의 각 요소와 K를 비교
- K가 없으면 -1 반환

##### 알고리즘 정의

input: 배열 E, 요소의 수 n, 찾아야 하는 값 K
output: E에서 K의 위치 또는 -1

\*\* 알고리즘 사용 시 0-based index, 1-based index 사용, 유의할 것

```c
int seqSearch(int[] E, int n, int K){
  int ans, idx;
  ans = -1; // 실패 가정
  for (idx = 0; idx < n; idx++){
    if (E[idx] == K){
      ans = idx; // 성공
      break; // 종료
    }
  }
  return ans;
}
```

수행시간: W(n) = n
K가 존재하지 않거나 마지막 요소에 있는 경우 n번 비교 연산을 해야 함

### 알고리즘 분석

- 실험적 분석
  - 알고리즘 구현 필수적
  - 구현하는 사람의 실력이 동일해야 함
  - 작동하는 SW, HW가 동일해야 함
  - 실험에 포함되지 않는 input에 대해서는 측정 불가
- 이론적 분석
  - 직접 구현할 필요 없이, 의사코드로도 분석 가능
  - 인풋크기 n에 대한 함수로 표현 -- big O notation
  - 모든 가능성에 대해서 분석 가능 -- worst case, best case
  - SW, HW 환경에 관계없이 알고리즘 분석 가능

##### 알고리즘이 수행하는 일의 양을 측정해 알고리즘 분석

- 기본 연산: 알고리즘에서 가장 기본이 되는 연산
- 기본 연산의 수를 세어 알고리즘이 수행하는 일의 양 계산

##### Worst-Case

- W(n): 인풋 크기 n에 대해서 알고리즘이 수행하는 최대 기본 연산의 개수
  - 기본 연산을 가장 많이 사용하는 경우
- 가장 기본이 되는 분석 방법

##### Average-Behavior

- 새로운 알고리즘 개발 시 장점을 찾기 위해 분석
- W(n)은 같아도 평균치에서 빠르면 좋은 알고리즘

##### Correctness

##### Optimality

### 수학 기본 지식

$\displaystyle\sum_{i=0}^{n}{i} = {\frac{n(n+1)}{2}}$

$\displaystyle\sum_{i=0}^{n}{(i)^k} = {\frac{n^{k+1}}{k+1}}$

$\displaystyle\sum_{i=0}^{n}{(a)^r} = {\frac{a(r^n-1)}{r-1}}$

$\displaystyle\sum_{i=0}^{k}{i(2)^i} = {(k-1)2^{k+1}+2}$

$if\,A\,then\,B = not A \cup B$
